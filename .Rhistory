# Read in Vaisala data
vaisala.data <- read.csv(vaisala.file.path)
vaisala.data <- vaisala.data[complete.cases(vaisala.data),]
#data12 <- read.delim("Part 1 humidity.txt", stringsAsFactors = FALSE)
#colnames(data12) = c("probeTime","probe.rh","probe.temp")
#data13 <- fix_length(data12, nrow(data1))
elapsedTimeSec <- convertToSec(seePhase)
elapsedTimeHour <- elapsedTimeSec / 3600
#seePhase2 <- cbind(data1,elapsedTimeSec,elapsedTimeHour, data13)
seePhase2 <- cbind(seePhase, elapsedTimeSec, elapsedTimeHour) #adds elapsedTimeSec and elapsedTimeHour columns to SeePhase data (PMD)
#If we add the vds data to the seePhase data here we can plot a Phase vs Time graph with Temperature series
#As it stands, the Phase information is removed before the Temperature series is glued in from the VDS file
#Assign column names from data files to variables (for slicing later)
name.seePhase.time = colnames(seePhase2)[seePhase.time] #assigns name from time column to variable; column is assigned by seePhase.time variable in settings file (PMD)
name.seePhase.temperature = colnames(seePhase2)[seePhase.temperature] #assigns name from temperature column to variable; column is assigned by seePhase.temperature variable in settings file (PMD)
name.seePhase.phase = colnames(seePhase2)[seePhase.phase] #assigns name from phase column to variable; column is assigned by seePhase.phase variable in settings file (PMD)
name.vds.rh = colnames(vds2)[vds.rh] #should return 'rh' (PMD)
name.vds.temperature = colnames(vds2)[vds.temperature] #should return 'Temp' (PMD)
name.vds.cCO2 = colnames(vds2)[vds.cCO2] #returns 'Concentration.of.Gas...'(PMD)
name.vds.cO2 = colnames(vds2)[vds.cO2] #returns 'elapsed.time'...should return O2 concentration (PMD)
name.vds.time = colnames(vds2)[vds.time] #returns 'time.s.' (PMD)
name.vds.include = colnames(vds2)[vds.include] #returns 'Include' (PMD)
traceback()
colnames(vds2)[vds.rh] = "rh" #changes RH column name from 'RH....' to 'rh' in vds2 (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
setwd("~/GitHub/SeePhase-M")
# main file
###Added a change b/c last commit was not synched online github
# Styling notes:
# Any programming notes that are to be deleted once some function/feature is implemented
# are preceeded by three hash marks, eg. '### Find a way to combine RH probe data with seePhase data.'
# Code that is commented out because it is not currently working or needed is preceeded with a #and no space
# Permanent comments begin with a # and a space.
# Other styling choices are defined in Google's R Style Guide, https://google.github.io/styleguide/Rguide.xml
# Import required packages (PMD)
source('helperFunctions.R')
require(reshape2)
require(ggplot2)
require(manipulate) #allows the creation of an interactive plot
# Define global variables (PMD)
t <- Sys.time()
timeStamp <-  strftime(t,"%Y-%m-%d_%H-%M-%S")
# The Script
settings.lines <- readLines('settings.txt') #reads the lines of the settings file into a character vector (PMD)
for (i in 1:length(settings.lines)){
temp <- gsub("\\","/",settings.lines[i],fixed=TRUE)
eval(parse(text=temp))
}
# Load VDS file into a list, vds
vds <- read.delim(vdsFilePath)
# set number of columns to save from VDS file
vds <- vds[1:vds.num.columns.keep] #removes columns beyond vds.num.columns.keep, see settings file (PMD)
vds <- vds[!is.na(vds[1]),] #removes empty cells, which are imported as NA (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
#line below can be moved to helperfunction genElapsedTime
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
colnames(vds2)[vds.rh] = "rh" #changes RH column name from 'RH....' to 'rh' in vds2 (PMD)
# read in the SeePhase data (as a list) (PMD)
seePhase <- read.csv(dataFilePath)
# Read in Vaisala data
vaisala.data <- read.csv(vaisala.file.path)
vaisala.data <- vaisala.data[complete.cases(vaisala.data),]
#data12 <- read.delim("Part 1 humidity.txt", stringsAsFactors = FALSE)
#colnames(data12) = c("probeTime","probe.rh","probe.temp")
#data13 <- fix_length(data12, nrow(data1))
elapsedTimeSec <- convertToSec(seePhase)
elapsedTimeHour <- elapsedTimeSec / 3600
#seePhase2 <- cbind(data1,elapsedTimeSec,elapsedTimeHour, data13)
seePhase2 <- cbind(seePhase, elapsedTimeSec, elapsedTimeHour) #adds elapsedTimeSec and elapsedTimeHour columns to SeePhase data (PMD)
#If we add the vds data to the seePhase data here we can plot a Phase vs Time graph with Temperature series
#As it stands, the Phase information is removed before the Temperature series is glued in from the VDS file
#Assign column names from data files to variables (for slicing later)
name.seePhase.time = colnames(seePhase2)[seePhase.time] #assigns name from time column to variable; column is assigned by seePhase.time variable in settings file (PMD)
name.seePhase.temperature = colnames(seePhase2)[seePhase.temperature] #assigns name from temperature column to variable; column is assigned by seePhase.temperature variable in settings file (PMD)
name.seePhase.phase = colnames(seePhase2)[seePhase.phase] #assigns name from phase column to variable; column is assigned by seePhase.phase variable in settings file (PMD)
name.vds.rh = colnames(vds2)[vds.rh] #should return 'rh' (PMD)
name.vds.temperature = colnames(vds2)[vds.temperature] #should return 'Temp' (PMD)
name.vds.cCO2 = colnames(vds2)[vds.cCO2] #returns 'Concentration.of.Gas...'(PMD)
name.vds.cO2 = colnames(vds2)[vds.cO2] #returns 'elapsed.time'...should return O2 concentration (PMD)
name.vds.time = colnames(vds2)[vds.time] #returns 'time.s.' (PMD)
name.vds.include = colnames(vds2)[vds.include] #returns 'Include' (PMD)
# main file
###Added a change b/c last commit was not synched online github
# Styling notes:
# Any programming notes that are to be deleted once some function/feature is implemented
# are preceeded by three hash marks, eg. '### Find a way to combine RH probe data with seePhase data.'
# Code that is commented out because it is not currently working or needed is preceeded with a #and no space
# Permanent comments begin with a # and a space.
# Other styling choices are defined in Google's R Style Guide, https://google.github.io/styleguide/Rguide.xml
# Import required packages (PMD)
source('helperFunctions.R')
require(reshape2)
require(ggplot2)
require(manipulate) #allows the creation of an interactive plot
# Define global variables (PMD)
t <- Sys.time()
timeStamp <-  strftime(t,"%Y-%m-%d_%H-%M-%S")
# The Script
settings.lines <- readLines('settings.txt') #reads the lines of the settings file into a character vector (PMD)
for (i in 1:length(settings.lines)){
temp <- gsub("\\","/",settings.lines[i],fixed=TRUE)
eval(parse(text=temp))
}
# Load VDS file into a list, vds
vds <- read.delim(vdsFilePath)
# set number of columns to save from VDS file
vds <- vds[1:vds.num.columns.keep] #removes columns beyond vds.num.columns.keep, see settings file (PMD)
vds <- vds[!is.na(vds[1]),] #removes empty cells, which are imported as NA (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
#line below can be moved to helperfunction genElapsedTime
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
colnames(vds2)[vds.rh] = "rh" #changes RH column name from 'RH....' to 'rh' in vds2 (PMD)
# read in the SeePhase data (as a list) (PMD)
seePhase <- read.csv(dataFilePath)
# Read in Vaisala data
vaisala.data <- read.csv(vaisala.file.path)
vaisala.data <- vaisala.data[complete.cases(vaisala.data),]
#data12 <- read.delim("Part 1 humidity.txt", stringsAsFactors = FALSE)
#colnames(data12) = c("probeTime","probe.rh","probe.temp")
#data13 <- fix_length(data12, nrow(data1))
elapsedTimeSec <- convertToSec(seePhase)
elapsedTimeHour <- elapsedTimeSec / 3600
#seePhase2 <- cbind(data1,elapsedTimeSec,elapsedTimeHour, data13)
seePhase2 <- cbind(seePhase, elapsedTimeSec, elapsedTimeHour) #adds elapsedTimeSec and elapsedTimeHour columns to SeePhase data (PMD)
#If we add the vds data to the seePhase data here we can plot a Phase vs Time graph with Temperature series
#As it stands, the Phase information is removed before the Temperature series is glued in from the VDS file
#Assign column names from data files to variables (for slicing later)
name.seePhase.time = colnames(seePhase2)[seePhase.time] #assigns name from time column to variable; column is assigned by seePhase.time variable in settings file (PMD)
name.seePhase.temperature = colnames(seePhase2)[seePhase.temperature] #assigns name from temperature column to variable; column is assigned by seePhase.temperature variable in settings file (PMD)
name.seePhase.phase = colnames(seePhase2)[seePhase.phase] #assigns name from phase column to variable; column is assigned by seePhase.phase variable in settings file (PMD)
name.vds.rh = colnames(vds2)[vds.rh] #should return 'rh' (PMD)
name.vds.temperature = colnames(vds2)[vds.temperature] #should return 'Temp' (PMD)
name.vds.cCO2 = colnames(vds2)[vds.cCO2] #returns 'Concentration.of.Gas...'(PMD)
name.vds.cO2 = colnames(vds2)[vds.cO2] #returns 'elapsed.time'...should return O2 concentration (PMD)
name.vds.time = colnames(vds2)[vds.time] #returns 'time.s.' (PMD)
name.vds.include = colnames(vds2)[vds.include] #returns 'Include' (PMD)
vds
vds <- vds[!is.na(vds[1]),] #removes empty cells, which are imported as NA (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
source('helperFunctions.R')
source('~/GitHub/SeePhase-M/helperFunctions.R')
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
# main file
###Added a change b/c last commit was not synched online github
# Styling notes:
# Any programming notes that are to be deleted once some function/feature is implemented
# are preceeded by three hash marks, eg. '### Find a way to combine RH probe data with seePhase data.'
# Code that is commented out because it is not currently working or needed is preceeded with a #and no space
# Permanent comments begin with a # and a space.
# Other styling choices are defined in Google's R Style Guide, https://google.github.io/styleguide/Rguide.xml
# Import required packages (PMD)
source('helperFunctions.R')
require(reshape2)
require(ggplot2)
require(manipulate) #allows the creation of an interactive plot
# Define global variables (PMD)
t <- Sys.time()
timeStamp <-  strftime(t,"%Y-%m-%d_%H-%M-%S")
# The Script
settings.lines <- readLines('settings.txt') #reads the lines of the settings file into a character vector (PMD)
for (i in 1:length(settings.lines)){
temp <- gsub("\\","/",settings.lines[i],fixed=TRUE)
eval(parse(text=temp))
}
# Load VDS file into a list, vds
vds <- read.delim(vdsFilePath)
# set number of columns to save from VDS file
vds <- vds[1:vds.num.columns.keep] #removes columns beyond vds.num.columns.keep, see settings file (PMD)
vds <- vds[!is.na(vds[1]),] #removes empty cells, which are imported as NA (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
#line below can be moved to helperfunction genElapsedTime
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
colnames(vds2)[vds.rh] = "rh" #changes RH column name from 'RH....' to 'rh' in vds2 (PMD)
# read in the SeePhase data (as a list) (PMD)
seePhase <- read.csv(dataFilePath)
# Read in Vaisala data
vaisala.data <- read.csv(vaisala.file.path)
vaisala.data <- vaisala.data[complete.cases(vaisala.data),]
#data12 <- read.delim("Part 1 humidity.txt", stringsAsFactors = FALSE)
#colnames(data12) = c("probeTime","probe.rh","probe.temp")
#data13 <- fix_length(data12, nrow(data1))
elapsedTimeSec <- convertToSec(seePhase)
elapsedTimeHour <- elapsedTimeSec / 3600
#seePhase2 <- cbind(data1,elapsedTimeSec,elapsedTimeHour, data13)
seePhase2 <- cbind(seePhase, elapsedTimeSec, elapsedTimeHour) #adds elapsedTimeSec and elapsedTimeHour columns to SeePhase data (PMD)
#If we add the vds data to the seePhase data here we can plot a Phase vs Time graph with Temperature series
#As it stands, the Phase information is removed before the Temperature series is glued in from the VDS file
#Assign column names from data files to variables (for slicing later)
name.seePhase.time = colnames(seePhase2)[seePhase.time] #assigns name from time column to variable; column is assigned by seePhase.time variable in settings file (PMD)
name.seePhase.temperature = colnames(seePhase2)[seePhase.temperature] #assigns name from temperature column to variable; column is assigned by seePhase.temperature variable in settings file (PMD)
name.seePhase.phase = colnames(seePhase2)[seePhase.phase] #assigns name from phase column to variable; column is assigned by seePhase.phase variable in settings file (PMD)
name.vds.rh = colnames(vds2)[vds.rh] #should return 'rh' (PMD)
name.vds.temperature = colnames(vds2)[vds.temperature] #should return 'Temp' (PMD)
name.vds.cCO2 = colnames(vds2)[vds.cCO2] #returns 'Concentration.of.Gas...'(PMD)
name.vds.cO2 = colnames(vds2)[vds.cO2] #returns 'elapsed.time'...should return O2 concentration (PMD)
name.vds.time = colnames(vds2)[vds.time] #returns 'time.s.' (PMD)
name.vds.include = colnames(vds2)[vds.include] #returns 'Include' (PMD)
linegraph_offset <- function(variableRH, time, offset){
for (i in 1:length(time)){
time <- time[i] + offset
return(time)
}
}
linegraph_offset <- function(variableRH, time, offset){
for (i in 1:length(time)){
time <- time[i] + offset
print(time)
}
}
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot$elapsedTimeHour,temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
print(i)
}
}
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
return(time + offset)
}
}
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot$elapsedTimeHour,temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
return(time + offset)
print(time + offset)
}
}
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot$elapsedTimeHour,temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
temp.plot[,1]
temp.plot[,2]
temp.plot
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
return(time + offset)
print(time + offset)
return(c(time, variableRH))
}
}
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
temp.plot[,1]
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
temp.plot
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
return(time + offset)
#print(time + offset)
return(c(time, variableRH))
}
}
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
#return(time + offset)
#print(time + offset)
return(c(time, variableRH))
}
}
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
setwd("~/GitHub/SeePhase-M")
linegraph_offset <- function(variableRH, time, offset){
for (i in time){
#return(time + offset)
#print(time + offset)
return(c(time, variableRH))
}
}
linegraph_offset(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset2 <- function(variableRH, time, offset){
for (i in time){
#return(time + offset)
#print(time + offset)
return(c(time, variableRH))
}
}
linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset2 <- function(variableRH, time, offset){
for (i in time){
#return(time + offset)
#print(time + offset)
#return(c(time, variableRH))
}
}
linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset2 <- function(variableRH, time, offset){
for (i in time){
#return(time + offset)
#print(time + offset)
return(c(time, variableRH))
}
}
linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
linegraph_offset2 <- function(variableRH, time, offset){
for (i in time){
time[i] <- time[i] + offset
}
}
linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
# main file
###Added a change b/c last commit was not synched online github
# Styling notes:
# Any programming notes that are to be deleted once some function/feature is implemented
# are preceeded by three hash marks, eg. '### Find a way to combine RH probe data with seePhase data.'
# Code that is commented out because it is not currently working or needed is preceeded with a #and no space
# Permanent comments begin with a # and a space.
# Other styling choices are defined in Google's R Style Guide, https://google.github.io/styleguide/Rguide.xml
# Import required packages (PMD)
source('helperFunctions.R')
require(reshape2)
require(ggplot2)
require(manipulate) #allows the creation of an interactive plot
# Define global variables (PMD)
t <- Sys.time()
timeStamp <-  strftime(t,"%Y-%m-%d_%H-%M-%S")
# The Script
settings.lines <- readLines('settings.txt') #reads the lines of the settings file into a character vector (PMD)
for (i in 1:length(settings.lines)){
temp <- gsub("\\","/",settings.lines[i],fixed=TRUE)
eval(parse(text=temp))
}
# Load VDS file into a list, vds
vds <- read.delim(vdsFilePath)
# set number of columns to save from VDS file
vds <- vds[1:vds.num.columns.keep] #removes columns beyond vds.num.columns.keep, see settings file (PMD)
vds <- vds[!is.na(vds[1]),] #removes empty cells, which are imported as NA (PMD)
elapsed.time <- genElapsedTime(vdsFilePath) #stores elapsed time of VDS method as a double, using helper function genElapsedTime (PMD)
#line below can be moved to helperfunction genElapsedTime
elapsed.time <- elapsed.time[!is.na(elapsed.time)] #removes blank cells from elapsed.time (PMD)
vds2 <- cbind(vds, elapsed.time) #creates a new list, vds2, with elapsed time as a column (PMD)
colnames(vds2)[vds.rh] = "rh" #changes RH column name from 'RH....' to 'rh' in vds2 (PMD)
# read in the SeePhase data (as a list) (PMD)
seePhase <- read.csv(dataFilePath)
# Read in Vaisala data
vaisala.data <- read.csv(vaisala.file.path)
vaisala.data <- vaisala.data[complete.cases(vaisala.data),]
#data12 <- read.delim("Part 1 humidity.txt", stringsAsFactors = FALSE)
#colnames(data12) = c("probeTime","probe.rh","probe.temp")
#data13 <- fix_length(data12, nrow(data1))
elapsedTimeSec <- convertToSec(seePhase)
elapsedTimeHour <- elapsedTimeSec / 3600
#seePhase2 <- cbind(data1,elapsedTimeSec,elapsedTimeHour, data13)
seePhase2 <- cbind(seePhase, elapsedTimeSec, elapsedTimeHour) #adds elapsedTimeSec and elapsedTimeHour columns to SeePhase data (PMD)
#If we add the vds data to the seePhase data here we can plot a Phase vs Time graph with Temperature series
#As it stands, the Phase information is removed before the Temperature series is glued in from the VDS file
#Assign column names from data files to variables (for slicing later)
name.seePhase.time = colnames(seePhase2)[seePhase.time] #assigns name from time column to variable; column is assigned by seePhase.time variable in settings file (PMD)
name.seePhase.temperature = colnames(seePhase2)[seePhase.temperature] #assigns name from temperature column to variable; column is assigned by seePhase.temperature variable in settings file (PMD)
name.seePhase.phase = colnames(seePhase2)[seePhase.phase] #assigns name from phase column to variable; column is assigned by seePhase.phase variable in settings file (PMD)
name.vds.rh = colnames(vds2)[vds.rh] #should return 'rh' (PMD)
name.vds.temperature = colnames(vds2)[vds.temperature] #should return 'Temp' (PMD)
name.vds.cCO2 = colnames(vds2)[vds.cCO2] #returns 'Concentration.of.Gas...'(PMD)
name.vds.cO2 = colnames(vds2)[vds.cO2] #returns 'elapsed.time'...should return O2 concentration (PMD)
name.vds.time = colnames(vds2)[vds.time] #returns 'time.s.' (PMD)
name.vds.include = colnames(vds2)[vds.include] #returns 'Include' (PMD)
linegraph_offset2 <- function(variableRH, time, offset){
for (i in time){
time[i] <- time[i] + offset
}
}
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, 1)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
createPlot <- function(x,y,xmin,xmax,ymin,ymax,offset_value,phase_data){
temp.plot <- linegraph_offset2(vaisala.data$RH..., vaisala.data$VaisalaTimeHours, offset_value)
plot(x,y,type='l',xlim=c(xmin,xmax),ylim=c(ymin,ymax))
lines(vaisala.data$VaisalaTimeHours,vaisala.data[,2],col="red")
points(temp.plot[,1],temp.plot[,2],col="red")
}
offset_value_main = 0
#Generate the interactive plot for finding an acceptable offset value
manipulate(
{createPlot(seePhase2$elapsedTimeHour,seePhase2[,seePhase.phase],x.min,x.max,y.min,y.max,offset_value,2)
offset_value_main <- offset_value},
x.min = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=0),
x.max = slider(0,as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)]),initial=as.integer(vaisala.data$VaisalaTimeHours[length(vaisala.data$VaisalaTimeHours)])),
y.min = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=0),
y.max = slider(0,as.integer(max(vaisala.data[,2]))+10,initial=as.integer(max(vaisala.data[,2]))+10),
offset_value = slider(-3600,3600,initial=0)
)
?"manipulate"
